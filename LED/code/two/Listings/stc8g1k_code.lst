C51 COMPILER V9.59.0.0   STC8G1K_CODE                                                      02/20/2023 19:03:30 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE STC8G1K_CODE
OBJECT MODULE PLACED IN .\Objects\stc8g1k_code.obj
COMPILER INVOKED BY: C:\Keil_C51\C51\BIN\C51.EXE src\stc8g1k_code.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\src;.\Driver\inc;.
                    -\Driver\src) DEBUG OBJECTEXTEND PRINT(.\Listings\stc8g1k_code.lst) TABS(2) OBJECT(.\Objects\stc8g1k_code.obj)

line level    source

   1          /*******************åŠŸèƒ½æè¿°*******************
   2          è§¦æ‘¸åŠŸèƒ½
   3          
   4          1ã€ç¬¬ä¸€æ¬¡è§¦æ‘¸ç»§ç”µå™¨1 (PCBæ¿æœ€è¾¹ä¸Šè¿™ä¸ªç»§ç”µå™¨)æ¥é€š220Vç”µæºã€‚
   5          
   6          2ã€ç¬¬äºŒæ¬¡è§¦æ‘¸ç»§ç”µå™¨1 (PCBæ¿æœ€è¾¹ä¸Šè¿™ä¸ªç»§ç”µå™¨)æ–­å¼€ï¼Œç»§ç”µå™¨2 (PCBæ¿ä¸­é—´ç»§ç”µå™¨)æ
             -¥é€š220Vç”µæºã€‚
   7          
   8          3ã€ç¬¬ä¸‰æ¬¡è§¦æ‘¸ç»§ç”µå™¨1 ã€æ‘¸ç»§ç”µå™¨2 éƒ½æ¥é€š220Vç”µæºã€‚
   9          
  10          4ã€ç¬¬å››æ¬¡è§¦æ‘¸åˆå›åˆ°ç¬¬ä¸€æ¬¡è§¦æ‘¸å®ç°çš„åŠŸèƒ½ï¼Œåªæœ‰(PCBæ¿æœ€è¾¹ä¸Šè¿™ä¸ªç»§ç”µå™¨)æ¥é€š2
             -20Vç”µæºã€‚
  11          ************************************************/
  12          
  13          #include  "stc8g1k_code.h"    
  14          #include  "STC8xxxx.h"  
  15          #include  "STC8G_H_GPIO.h"
  16          #include  "STC8G_H_ADC.h"
  17          #include  "STC8G_H_NVIC.h"
  18          #include  "string.h"
  19          #include  "global.h"
  20          #include  "led2_digital_tube.h"
  21          #include  "infrared.h"
  22          #include  "touch.h"
  23          #include  "temperature.h"
  24          #include  "buzzer.h"
  25          #include  "encryptionDecryption.h"
  26          
  27          #ifdef    UART_ENABLE
              #include  "uart.h"
              #endif
  30          
  31          #define ET2 0x04
  32           
  33          //æ•°æ®å®šä¹‰
  34          u8 si_level;        //å¯æ§ç¡…æ§åˆ¶çº§æ•° 0å…³é—­ æœ€å¤§3æ¡£
  35          
  36          //å‡½æ•°å£°æ˜
  37          static void Timer0Init(void);   //å®šæ—¶è®¡æ•°å™¨0åˆå§‹åŒ–å‡½æ•°
  38          static void Timer1Init(void);   //å®šæ—¶è®¡æ•°å™¨1åˆå§‹åŒ–å‡½æ•°
  39          static void Timer2Init(void);   //10æ¯«ç§’@6.000MHz
  40          static void gpio_config(void);
  41          static void Int1_init(void);
  42          static void Int0_init(void);
  43          void rdelay_acton_fun(u8 action_value);
  44          void delay(u16 count);    //å»¶æ—¶å‡½æ•°å£°æ˜
  45          void write_eeprom_data(void);
  46          
  47          
  48          
  49          //-------------------------ä¸»å‡½æ•°----------------------------
  50          void main(void)
  51          {
  52   1        gpio_config();
C51 COMPILER V9.59.0.0   STC8G1K_CODE                                                      02/20/2023 19:03:30 PAGE 2   

  53   1      
  54   1        Timer0Init();   //å®šæ—¶è®¡æ•°å™¨0åˆå§‹åŒ–å‡½æ•°
  55   1        Timer1Init();   //å®šæ—¶è®¡æ•°å™¨1åˆå§‹åŒ–å‡½æ•°
  56   1        Timer2Init();   //10æ¯«ç§’@6.000MHz
  57   1        //è¿‡é›¶æ£€æµ‹
  58   1        Int0_init();    //å¤–éƒ¨ä¸­æ–­0åˆå§‹åŒ–å‡½æ•°  è¿‡é›¶æ£€æµ‹è„š
  59   1        //Int3_init();    //å¤–éƒ¨ä¸­æ–­3åˆå§‹åŒ–å‡½æ•°  
  60   1        infrared_init(); //çº¢å¤–åˆå§‹åŒ–å‡½æ•°
  61   1        touch_init();    //è§¦æ‘¸åˆå§‹åŒ–å‡½æ•°
  62   1        buzzer_init();
  63   1        
  64   1        #ifdef UART_ENABLE
                UartInit();
                #endif
  67   1        EA = 1;         //å¼€ä¸­æ–­
  68   1        delay(500);     //ç­‰å¾…é…ç½®ç¨³å®š
  69   1        #ifdef UART_ENABLE
                PrintString1("STC8:\r\n");    //UART1å‘é€ä¸€ä¸ªå­—ç¬¦ä¸²
                #endif
  72   1        
  73   1        WDT_CONTR = 0x23; //ä½¿èƒ½çœ‹é—¨ç‹—,æº¢å‡ºæ—¶é—´çº¦ä¸º 0.5s
  74   1        //WDT_CONTR = 0x24; //ä½¿èƒ½çœ‹é—¨ç‹—,æº¢å‡ºæ—¶é—´çº¦ä¸º 1s
  75   1        // WDT_CONTR = 0x27; //ä½¿èƒ½çœ‹é—¨ç‹—,æº¢å‡ºæ—¶é—´çº¦ä¸º 8s
  76   1          
  77   1        temperature_init(); 
  78   1          rdelay_acton_fun(0);
  79   1        si_level =0;
  80   1        ID:
  81   1        if(id_compare())
  82   1        {
  83   2           WDT_CONTR |= 0x10;
  84   2           delay(500);
  85   2           goto ID;
  86   2        } 
  87   1        while(1)
  88   1        {   
  89   2           WDT_CONTR |= 0x10; //æ¸…çœ‹é—¨ç‹—,å¦åˆ™ç³»ç»Ÿå¤ä½
  90   2           temperature_get_deal();    
  91   2           if(overtemperature_check())
  92   2              continue;
  93   2           infrared_check_deal(); 
  94   2           touch_check_deal();//è§¦æ‘¸æ£€æµ‹
  95   2           buzzer_run();
  96   2           //write_eeprom_data();
  97   2        }
  98   1      }
  99          void write_eeprom_data(void)
 100          {
 101   1         char idata *ID;
 102   1         bit flag=1;
 103   1         u8  addr = flag;
 104   1         u8 i;
 105   1         addr |= 0xf0;
 106   1        
 107   1         ID = addr | 0x01; 
 108   1        
 109   1         for(i=0;i<7;i++)
 110   1        {
 111   2           addr = ID[i];
 112   2           //eep_input(1,addr);
 113   2          #ifdef UART_ENABLE
                   TX1_write2buff(addr); 
C51 COMPILER V9.59.0.0   STC8G1K_CODE                                                      02/20/2023 19:03:30 PAGE 3   

                  #endif
 116   2        }
 117   1        
 118   1        #ifdef UART_ENABLE
                   TX1_write2buff(0xff); 
                #endif
 121   1        ID = (char idata *)0xf1; 
 122   1        for(i=0;i<7;i++)
 123   1        {
 124   2           addr = ID[i];
 125   2           //eep_input(1,addr);
 126   2          #ifdef UART_ENABLE
                   TX1_write2buff(addr); 
                  #endif
 129   2        }
 130   1        #ifdef UART_ENABLE
                   TX1_write2buff(0xaa); 
                #endif
 133   1      }
 134          
 135          static void gpio_config(void)
 136          {
 137   1        
 138   1         //æ•°ç ç®¡å¼•è„šåˆå§‹åŒ–
 139   1         P3_MODE_OUT_PP(GPIO_Pin_4 |GPIO_Pin_5 |GPIO_Pin_7);   //æ¨æŒ½è¾“å‡ºA B C
 140   1         P1_MODE_OUT_PP(GPIO_Pin_0 |GPIO_Pin_2 |GPIO_Pin_3 |GPIO_Pin_4);   //æ¨æŒ½è¾“å‡ºD E F G 
 141   1         P1_MODE_OUT_PP(GPIO_Pin_6);   //æ¨æŒ½è¾“å‡ºDIG2  
 142   1         P5_MODE_OUT_PP(GPIO_Pin_4);   //æ¨æŒ½è¾“å‡ºDIG1 
 143   1         P54 = 0; P16=0;  //æ•°ç ç®¡ä¸æ˜¾ç¤º
 144   1      
 145   1         //P5_MODE_OUT_PP(GPIO_Pin_5);   //æ¨æŒ½è¾“å‡ºAH
 146   1         //P55 = 1;
 147   1        
 148   1         //è§¦æ‘¸ICå¼•è„šåˆå§‹åŒ– 
 149   1         P3_ST_ENABLE(GPIO_Pin_3);     //æ–½å¯†ç‰¹è§¦å‘ä½¿èƒ½
 150   1         P3_MODE_IN_HIZ(GPIO_Pin_3);   //é«˜é˜»è¾“å…¥ 
 151   1         //Int2_init();  //P3.6/INT2ä¸‹é™æ²¿ä¸­æ–­
 152   1      
 153   1         //å¯æ§ç¡…æ§åˆ¶IOåˆå§‹åŒ–
 154   1         P1_MODE_OUT_PP(GPIO_Pin_7);   //æ¨æŒ½è¾“å‡º 
 155   1         SI_OFF();   //å…³æ–­å¯æ§ç¡…
 156   1         
 157   1         //èœ‚é¸£å™¨IOåˆå§‹åŒ–
 158   1         P1_MODE_OUT_PP(GPIO_Pin_1);   //æ¨æŒ½è¾“å‡º 
 159   1         P11=1;
 160   1        
 161   1      /*
 162   1          #if   0
 163   1        //STC8Gç³»åˆ—å•ç‰‡æœºé™¤P3.0å’ŒP3.1å¤–ï¼Œæ‰€æœ‰I/Oä¸Šç”µå‡ä¸ºé«˜é˜»è¾“å…¥çŠ¶æ€ï¼Œéœ€å…ˆé…ç½®å†ä½¿ç”¨
 164   1        P3M0 |=0x08;    //P3.3å¼•è„šä¸ºæ¨æŒ½è¾“å‡ºæ¨¡å¼
 165   1        P3M1 &=0xF7;    //P3.3å¼•è„šä¸ºæ¨æŒ½è¾“å‡ºæ¨¡å¼
 166   1        RSTCFG &=0xEF;    //å¤ä½å¼•è„šP5.4å½“åšæ™®é€šI/Oå¼•è„š
 167   1        P5M0 |=0x10;    //P5.4å¼•è„šä¸ºæ¨æŒ½è¾“å‡ºæ¨¡å¼
 168   1        P5M1 &=0xEF;    //P5.4å¼•è„šä¸ºæ¨æŒ½è¾“å‡ºæ¨¡å¼
 169   1        P5M0 &=0xDF;    //P5.5å¼•è„šä¸ºå‡†åŒå‘å£æ¨¡å¼
 170   1        P5M1 &=0xDF;    //P5.5å¼•è„šä¸ºå‡†åŒå‘å£æ¨¡å¼
 171   1        #endif
 172   1          GPIO_InitTypeDef  GPIO_InitStructure;   //ç»“æ„å®šä¹‰
 173   1      
 174   1          GPIO_InitStructure.Pin  = GPIO_Pin_0 | GPIO_Pin_1;    //æŒ‡å®šè¦åˆå§‹åŒ–çš„IO, GPIO_Pin_0 ~ GPIO_Pin_7
 175   1          GPIO_InitStructure.Mode = GPIO_PullUp;  //æŒ‡å®šIOçš„è¾“å…¥æˆ–è¾“å‡ºæ–¹å¼,GPIO_PullUp,GPIO_HighZ,GPIO_OU
             -T_OD,GPIO_OUT_PP
C51 COMPILER V9.59.0.0   STC8G1K_CODE                                                      02/20/2023 19:03:30 PAGE 4   

 176   1          GPIO_Inilize(GPIO_P3,&GPIO_InitStructure);  //åˆå§‹åŒ–
 177   1        
 178   1         P3_PULL_UP_ENABLE(GPIO_Pin_0 | GPIO_Pin_1);//      
 179   1         //P3_PULL_UP_ENABLE(GPIO_Pin_1);//
 180   1        
 181   1         P1_MODE_OUT_PP(GPIO_Pin_0);   //æ¨æŒ½è¾“å‡ºP1.0 æ§åˆ¶ä¸­é—´ç¬¬äºŒä¸ªç»§ç”µå™¨
 182   1         P3_MODE_OUT_PP(GPIO_Pin_6 |GPIO_Pin_7);   //æ¨æŒ½è¾“å‡ºP3.7 æ§åˆ¶è¾¹ä¸Šç¬¬ä¸€ä¸ªç»§ç”µå™¨  //æ¨æŒ½è¾“
             -å‡ºP3.6 çº¢å¤–ç®¡è§¦æ‘¸IC å°æ¿ç”µæºæ§åˆ¶
 183   1        
 184   1         //P3_MODE_OUT_PP(GPIO_Pin_6);   //æ¨æŒ½è¾“å‡ºP3.6 çº¢å¤–ç®¡è§¦æ‘¸IC å°æ¿ç”µæºæ§åˆ¶
 185   1         P3_MODE_IN_HIZ(GPIO_Pin_3 | GPIO_Pin_4);   //æ–½å¯†ç‰¹è§¦å‘ä½¿èƒ½P3.3 è¿æ¥è§¦æ‘¸ICè¾“å‡ºè„š
 186   1         //P3_MODE_IN_HIZ(GPIO_Pin_4);   //æ–½å¯†ç‰¹è§¦å‘ä½¿èƒ½P3.4 è¿æ¥çº¢å¤–ç®¡æ¥æ”¶è„š
 187   1        
 188   1         DELAY1_OFF;   
 189   1         DELAY2_OFF; 
 190   1         P36 = 0; 
 191   1      */
 192   1      }
 193          //-------------------------å»¶æ—¶å‡½æ•°----------------------------
 194          void delay(u16 count)
 195          {
 196   1        while(count--)
 197   1        {
 198   2          _nop_();
 199   2        }
 200   1      }
 201          //å‡½æ•°åŠŸèƒ½ï¼šå¤‡ä»½ä¸è¿˜åŸå‚æ•°
 202          void display_para(u8 bak)
 203          {
 204   1         static u8 btn_value_bak=0xff;
 205   1         if(1 == bak)
 206   1            btn_value_bak = btn_value;
 207   1         else
 208   1         {
 209   2             btn_value = btn_value_bak;
 210   2             rdelay_acton_fun(btn_value);
 211   2         }
 212   1      
 213   1      }
 214          void rdelay_acton_fun(u8 action_value)
 215          {
 216   1          led_display_enable=1; 
 217   1          buzzerEnableFlag = 1;
 218   1          if(method_res_compare())
 219   1            action_value = 6;
 220   1          
 221   1          switch(action_value)
 222   1          {
 223   2              case 0:  // æ–­å¼€æ‰€æœ‰ç»§ç”µå™¨
 224   2                led_display_enable=0;  //ä¸Šç”µLEDæ•°ç ç®¡ä¸æ˜¾ç¤º
 225   2                si_level = 0; 
 226   2              break;
 227   2              case 1:   //æ•°ç ç®¡æ˜¾ç¤º--
 228   2                  digital_value[0]=0xff;
 229   2                  digital_value[1]=0xff;
 230   2                  si_level = 0;
 231   2              break;
 232   2              case 2:  //æ•°ç ç®¡æ˜¾ç¤ºL1
 233   2                  digital_value[0]=0x10;
 234   2                  digital_value[1]=0x01;  
 235   2                  si_level = 1;
 236   2              break;
C51 COMPILER V9.59.0.0   STC8G1K_CODE                                                      02/20/2023 19:03:30 PAGE 5   

 237   2              case 3:
 238   2                  digital_value[0]=0x10;
 239   2                  digital_value[1]=0x02;
 240   2                  si_level = 2;
 241   2              break;
 242   2              case 4:
 243   2                  digital_value[0]=0x10;
 244   2                  digital_value[1]=0x03;
 245   2                  si_level = 3;
 246   2              break;
 247   2              case 5:  //æ•°ç ç®¡æ˜¾ç¤ºE1
 248   2                  digital_value[0]=0x0e;
 249   2                  digital_value[1]=0x01;
 250   2                  si_level = 0;
 251   2              break;
 252   2              case 6:  //æ•°ç ç®¡æ˜¾ç¤º1E
 253   2                  digital_value[0]=0x01;
 254   2                  digital_value[1]=0x0e;
 255   2                  si_level = 0;
 256   2              break;
 257   2              default:
 258   2                
 259   2              break;
 260   2          }
 261   1      }
 262          
 263          //-------------------------å®šæ—¶å™¨åˆå§‹åŒ–----------------------------
 264          static void Timer0Init(void)    //139å¾®ç§’@6.000MHz
 265          {
 266   1        AUXR &= 0x7F;   //å®šæ—¶å™¨æ—¶é’Ÿ12Tæ¨¡å¼
 267   1        TMOD &= 0xF0;   //è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 268   1        TMOD |= 0x02;   //è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 269   1        TL0 = 0xBA;   //è®¾ç½®å®šæ—¶åˆå€¼
 270   1        TH0 = 0xBA;   //è®¾ç½®å®šæ—¶é‡è½½å€¼
 271   1        TF0 = 0;    //æ¸…é™¤TF0æ ‡å¿—
 272   1        TR0 = 1;    //å®šæ—¶å™¨0å¼€å§‹è®¡æ—¶
 273   1        ET0 = 1;    //ä½¿èƒ½T0ä¸­æ–­
 274   1      }
 275          static void Timer1Init(void)    //125æ¯«ç§’@6.000MHz
 276          {
 277   1        AUXR &= 0xBF;   //å®šæ—¶å™¨æ—¶é’Ÿ12Tæ¨¡å¼
 278   1        TMOD &= 0x0F;   //è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 279   1        TL1 = 0xDC;   //è®¾ç½®å®šæ—¶åˆå€¼
 280   1        TH1 = 0x0B;   //è®¾ç½®å®šæ—¶åˆå€¼
 281   1        TF1 = 0;    //æ¸…é™¤TF1æ ‡å¿—
 282   1        TR1 = 1;    //å®šæ—¶å™¨1å¼€å§‹è®¡æ—¶
 283   1        
 284   1        ET1 = 1;    //ä½¿èƒ½T1ä¸­æ–­
 285   1      }
 286          static void Timer2Init(void)    //10æ¯«ç§’@6.000MHz
 287          {
 288   1        AUXINTIF &= ~T2IF; //æ¸…ä¸­æ–­æ ‡å¿—
 289   1        AUXR &= 0xFB;   //å®šæ—¶å™¨æ—¶é’Ÿ12Tæ¨¡å¼
 290   1        T2L = 0x78;   //è®¾ç½®å®šæ—¶åˆå€¼
 291   1        T2H = 0xEC;   //è®¾ç½®å®šæ—¶åˆå€¼
 292   1        AUXR &= ~0x10;//å®šæ—¶å™¨2ä¸è®¡æ—¶
 293   1        IE2 = ET2;    //ä½¿èƒ½å®šæ—¶å™¨ä¸­æ–­
 294   1      }
 295          
 296          //-------------------------å¤–éƒ¨ä¸­æ–­0è¿‡é›¶æ£€æµ‹ä¸­æ–­åˆå§‹åŒ–-------------------------
 297          static void Int0_init(void)
 298          {
C51 COMPILER V9.59.0.0   STC8G1K_CODE                                                      02/20/2023 19:03:30 PAGE 6   

 299   1        IT0 = 1;  //è§¦å‘æ–¹å¼ä¸ºä¸‹é™æ²¿è§¦å‘
 300   1        EX0 = 1;  //ä½¿èƒ½INT0ä¸­æ–­
 301   1      }
 302          
 303          
 304          //-------------------------å¤–éƒ¨ä¸­æ–­0æœåŠ¡å‡½æ•°-------------------------
 305          void INT0_ISR() interrupt INT0_VECTOR   //è¿‡é›¶æ£€æµ‹ä¸­æ–­
 306          {
 307   1        //å¯æ§ç¡…æ§åˆ¶æ–¹æ³•ï¼šè¿‡é›¶ç‚¹åå¯æ§ç¡…åœ¨æ²¡æœ‰å¤–éƒ¨è§¦å‘æ¡ä»¶ä¸‹ï¼Œè‡ªåŠ¨å…³é—­.
 308   1        //ç”¨time2ä½œå»¶æ—¶ï¼Œtime2æœ€é•¿å»¶æ—¶é•¿ä¸º10msï¼ŒæŠŠ10msåˆ†æˆ3ä»½ï¼Œå³æ¯ä»½æ—¶é•¿ä¸º3.3ms
 309   1        //ç¬¬ä¸€æ¡£å»¶æ—¶æ—¶é•¿ä¸º10-3.3ms=6.7msï¼Œç¬¬äºŒæ¡£å»¶æ—¶æ—¶é•¿ä¸º10-3.3ms*2=3.4msï¼Œç¬¬ä¸‰æ¡£å…¨æ³¢å½¢å
             -·¥ä½œä¸å»¶æ—¶.è¿‡é›¶ç‚¹æ—¶ç›´æ¥è§¦å‘å¯æ§ç¡…å¯¼é€š
 310   1        //æ‰€ä»¥ä¸€äºŒæ¡£å®šæ—¶å™¨åˆå§‹å€¼è®¡ç®—å¦‚ä¸‹ï¼š
 311   1        //incrementV=(0xffff-0xEC78)/4=0x0662; ---incrementVå˜é‡å€¼ï¼šæŠŠ10msåˆ†æˆ3ä»½æ¯ä¸€ä»½çš„åˆå§‹å€¼çš„
             -å¢é‡å€¼
 312   1        //timeVal=0xEC78 + incrementV * si_level;---preTimeValå˜é‡å€¼ï¼šå³æ˜¯ä¸€äºŒæ¡£å®šæ—¶å™¨åˆå§‹å€¼
 313   1        
 314   1           //u16  timeVal;// 0x0662; // 0x04c9; //0x1327;
 315   1           AUXR &= ~0x10;   //å®šæ—¶å™¨2åœæ­¢è®¡æ—¶
 316   1           
 317   1           switch(si_level)
 318   1           {
 319   2             case 0:
 320   2                SI_OFF();  //å…³æ–­å¯æ§ç¡… 
 321   2                return;
 322   2             case 1:
 323   2                 SI_OFF();  //å…³æ–­å¯æ§ç¡… 
 324   2                 //timeVal = 0xEC78 + 0x0662; //å®šæ—¶å™¨åˆå§‹å€¼è¶Šå¤§å»¶æ—¶æ—¶é•¿è¶ŠçŸ­,å®šæ—¶å™¨å·¥ä½œæ–¹å¼æ˜¯å
             -¢é‡æº¢å‡ºäº§ç”Ÿä¸­æ–­.
 325   2                 TH2=242;//timeVal/256;  62170/256;
 326   2                 TL2=218;//timeVal%256;  62170-61952
 327   2              break;
 328   2             case 2:
 329   2                 SI_OFF();  //å…³æ–­å¯æ§ç¡… 
 330   2                 //timeVal = 0xEC78 + 0x0662 *2;
 331   2                 TH2=249;//timeVal/256;   63804/256
 332   2                 TL2=60;//timeVal%256;   63804-63744
 333   2              break;
 334   2             case 3:
 335   2                 SI_ON();   //å¼€å¯å¯æ§ç¡…
 336   2                 return;
 337   2              break;
 338   2           } 
 339   1              
 340   1           AUXR |= 0x10;    //å®šæ—¶å™¨2å¼€å§‹è®¡æ—¶;
 341   1          
 342   1      }
 343          
 344          
 345          
 346          void INT2_ISR() interrupt INT2_VECTOR  //è§¦æ‘¸æŒ‰é”®
 347          {
 348   1        
 349   1      }
 350          u8 display_cnt=0;
 351          void Time0_Handler_Callback(void)   interrupt TIMER0_VECTOR   //139us è¿›ä¸­æ–­æ—¶å·²ç»æ¸…é™¤æ ‡å¿—//ä»»åŠ¡
             -æ ‡è®°å›è°ƒå‡½æ•°
 352          {
 353   1         if(IR_time < 0xfc)
 354   1           IR_time++;
 355   1        
 356   1         Touch_time++;
C51 COMPILER V9.59.0.0   STC8G1K_CODE                                                      02/20/2023 19:03:30 PAGE 7   

 357   1      
 358   1         if(display_cnt++ > 40)
 359   1         {
 360   2             display_cnt = 0;
 361   2             led_display();
 362   2         }
 363   1           
 364   1      }
 365          void Time1_Handler_Callback(void) interrupt TIMER1_VECTOR   //125ms è¿›ä¸­æ–­æ—¶å·²ç»æ¸…é™¤æ ‡å¿—//ä»»åŠ¡æ
             - ‡è®°å›è°ƒå‡½æ•°
 366          {
 367   1        static u8 secCount=0;
 368   1      
 369   1        buzzer_timer++;
 370   1        
 371   1        if(++secCount >= 8)
 372   1        {
 373   2           secCount = 0;
 374   2           secFlag=1;
 375   2        }
 376   1        
 377   1        
 378   1        #if 0
                count--;
                if(count == 0)
                {
                   IR_TimeFlag = 1;
                   ET1 = 1;//
                }
                #endif
 386   1        
 387   1      }
 388          
 389          void Time2_Handler_Callback(void) interrupt TIMER2_VECTOR 
 390          {
 391   1          AUXINTIF &= ~T2IF; //æ¸…ä¸­æ–­æ ‡å¿—
 392   1          SI_ON();   //å¼€å¯å¯æ§ç¡…
 393   1          //delay(10);  //å»¶æ—¶2us
 394   1          //SI_OFF();  //å…³æ–­å¯æ§ç¡… 
 395   1          
 396   1      }
 397          
 398          
 399          
 400          
 401          
 402          
 403          
 404          
 405          //-------------------------å®šæ—¶å™¨0åˆå§‹åŒ–----------------------------
 406          #if 0
              static void Time0_init(void)  //139å¾®ç§’@11.0592MHz
              {
                AUXR &= 0x7F; //å®šæ—¶å™¨æ—¶é’Ÿ12Tæ¨¡å¼ï¼Œå·¥ä½œæ–¹å¼2
                TMOD &= 0xF0; 
                TMOD |= 0x02; 
                TL0 = 0x80;   
                TH0 = 0x80;   
                TF0 = 0;    //æ¸…é™¤æ ‡å¿—
                ET0 = 1;    //ä½¿èƒ½T0ä¸­æ–­
                TR0 = 1;    //å¯åŠ¨T0
              }
C51 COMPILER V9.59.0.0   STC8G1K_CODE                                                      02/20/2023 19:03:30 PAGE 8   

              //-------------------------å®šæ—¶å™¨1åˆå§‹åŒ–---------------------------
              
              static void Time1_init(void)  //278å¾®ç§’@11.0592MHz
              { 
                  AUXR |= 0x40;//æ¨¡å¼2 1T
                  TMOD &= 0x0F; 
              }
              #endif
 426          
 427          
 428          
 429          
 430          
 431          
 432          
 433          
 434          
 435          #if 0
              //-------------------------çº¢å¤–å‘é€é«˜ç”µå¹³----------------------------
              void Wait_High(a)//a*280uS 
              {
                unsigned char k;
                IR_TimeFlag = 0;
                count = a;
                T1_START();
                while(!IR_TimeFlag)  //38khzè½½æ³¢
                {
                  _nop_();
                  _nop_();
                  k = 23;
                  while (--k);
                  IR_IO = ~IR_IO;
                }
                IR_IO = 1;
              }
              //-------------------------çº¢å¤–å‘é€ä½ç”µå¹³----------------------------
              void Wait_Low(a)//a*280uS 
              {
                IR_IO = 1;
                IR_TimeFlag = 0;
                count = a;
                T1_START();
                while(!IR_TimeFlag);
              }
              //-------------------------çº¢å¤–å‘é€å•å­—èŠ‚æ•°æ®----------------------------
              void Send_IR(u8 dat)
              {
                unsigned char i,j;
                Wait_High(2);//0.56ms 
                Wait_Low(4);//1.12ms  
               
                for(j=0;j<8;j++)
                {
                  Wait_High(1);//0.28ms 
                  if(dat&0x01)
                  {
                    Wait_Low(2);// 0.56ms 
                  }
                  else
                  {
                    Wait_Low(1);//0.28ms
                  }
C51 COMPILER V9.59.0.0   STC8G1K_CODE                                                      02/20/2023 19:03:30 PAGE 9   

                  dat = dat>>1;    
                }
                
                Wait_High(1);//0.28ms 
              }
              #endif
 486          
 487          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    610    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
