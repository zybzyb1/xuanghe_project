C51 COMPILER V9.59.0.0   ENCRYPTIONDECRYPTION                                              02/21/2023 10:54:43 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE ENCRYPTIONDECRYPTION
OBJECT MODULE PLACED IN .\Objects\encryptionDecryption.obj
COMPILER INVOKED BY: C:\Keil_C51\C51\BIN\C51.EXE src\encryptionDecryption.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\src;.\Driv
                    -er\inc;.\Driver\src) DEBUG OBJECTEXTEND PRINT(.\Listings\encryptionDecryption.lst) TABS(2) OBJECT(.\Objects\encryptionDe
                    -cryption.obj)

line level    source

   1          #include  "encryptionDecryption.h"
   2          #include  "global.h"
   3          #include  "uart.h"
   4          //ID加密方法1、+11 ^85 -62  <<2     存储地址：0x0280
   5          //ID加密方法2、-0 +0 -0 +0     存储地址：0x0200
   6          
   7          u8  codeId1[7];
   8          u8  codeId2[7];
   9          
  10          char  *irId1;
  11          void readCodeId(u16 addr,u8 *idpt)
  12          { 
  13   1          u8 i;
  14   1        
  15   1          EA =0;
  16   1          irId1 = (char code *)(addr & 0xffff);
  17   1           
  18   1          for(i=0;i<7;i++)
  19   1          {  
  20   2               idpt[i] = irId1[i]; 
  21   2          } 
  22   1          EA =1;
  23   1      }
  24          
  25          //还原ID加密方法1、+11 ^85 -62  <<2    存储地址：0x0280
  26          void decryption(u8 *idpt)
  27          {   //加密方法二就是存储ID参数，这里取出ID地址，把ID数据按加密1的方法进行加密运算，再同存储地址0x02000值比
             -较是否相同
  28   1          u8 i=0;
  29   1          for(i=0;i<7;i++)
  30   1          {
  31   2              idpt[i] += 11;
  32   2              idpt[i] ^= 85; 
  33   2              idpt[i] -= 62; 
  34   2              idpt[i] <<= 2;  
  35   2          }
  36   1      }
  37              
  38          
  39          static void id_method1(void)
  40          {
  41   1          u16 adr = 0x0002;
  42   1          adr  <<= 8;
  43   1          adr  |= 0x0080;
  44   1          readCodeId(adr,codeId1);
  45   1      }
  46          
  47          static void id_method2(void)
  48          {
  49   1          u16 adr = 0x0002;
  50   1          adr  <<= 8;
  51   1          
  52   1          readCodeId(adr,codeId2);
C51 COMPILER V9.59.0.0   ENCRYPTIONDECRYPTION                                              02/21/2023 10:54:43 PAGE 2   

  53   1          decryption(codeId2);
  54   1      
  55   1      }
  56          
  57          u8 method_res_compare(void)
  58          {
  59   1          u8  i,res=0;
  60   1      
  61   1          id_method1();
  62   1          id_method2();
  63   1          
  64   1          for(i=0;i<7;i++)
  65   1          {
  66   2              
  67   2             if(codeId1[i] != codeId2[i])
  68   2             {
  69   3               res =1;
  70   3               break;
  71   3             }
  72   2          }
  73   1          return res;
  74   1      }
  75          
  76          
  77          
  78          u8 id_compare(void)
  79          {
  80   1          u8  i,res=0;
  81   1          u16 adr = 0x0002;
  82   1          adr  <<= 8;
  83   1        
  84   1          readCodeId(adr,codeId1);
  85   1        
  86   1          adr = 0x1f; //0x1ff9
  87   1          adr <<= 8;
  88   1          adr |= 0x00f9;
  89   1        
  90   1          readCodeId(adr,codeId2);
  91   1        
  92   1          for(i=0;i<7;i++)
  93   1          {
  94   2              
  95   2             if(codeId1[i] != codeId2[i])
  96   2             {
  97   3               res =1;
  98   3               break;
  99   3             }
 100   2          }
 101   1          return res; 
 102   1      }
 103          
 104          #if 0  //以下两个函数是两个异或的逆运算异同
              u8 xnor(u8 a, u8 b) {
                u8 res = 0;
                u8 i;
                u8 arr1[8] = { 0 };
                u8 arr2[8] = { 0 };
                u8 arr3[8] = {0};
                for (i = 0; i < 8; i++) {
                  arr1[i] = a % 2;
                  arr2[i] = b % 2;
                  a = a / 2;
C51 COMPILER V9.59.0.0   ENCRYPTIONDECRYPTION                                              02/21/2023 10:54:43 PAGE 3   

                  b = b / 2;
                }
                u8 m = 0;
                for (i = 7; i >= 0; i--) {
                  if (arr1[i] == 1 || arr2[i] == 1) {
                    m = i + 1;
                    break;
                  }
                }
                
                for (i = 0; i < m; i++) {
                  if (arr1[i] == arr2[i]) arr3[i] = 1;
                  else arr3[i] = 0;
                  res = res + arr3[i] * pow(2, i);
                }
                return res;
              }
              u8 same_or(u8 perm1,u8 perm2)
              {
                u8 tmp=perm1>perm2 ? perm1:perm2;
                u8 n=0, refer=~0, value;
                while(tmp>>n)
                  n++;
                refer<<=n;
                tmp=perm1&perm2;
                perm1=~(perm1|refer);//排除perm1高位上无效bit的干扰，如排除0001 1111的前面3个0
                perm2=~(perm2|refer);//同上
                value=perm1&perm2;
                return value|tmp;
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    292    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     17       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
