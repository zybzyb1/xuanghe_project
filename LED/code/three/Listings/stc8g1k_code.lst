C51 COMPILER V9.59.0.0   STC8G1K_CODE                                                      02/21/2023 10:54:57 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE STC8G1K_CODE
OBJECT MODULE PLACED IN .\Objects\stc8g1k_code.obj
COMPILER INVOKED BY: C:\Keil_C51\C51\BIN\C51.EXE src\stc8g1k_code.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\src;.\Driver\inc;.
                    -\Driver\src) DEBUG OBJECTEXTEND PRINT(.\Listings\stc8g1k_code.lst) TABS(2) OBJECT(.\Objects\stc8g1k_code.obj)

line level    source

   1          /*******************功能描述*******************
   2          触摸功能
   3          
   4          1、第一次触摸继电器1 (PCB板最边上这个继电器)接通220V电源。
   5          
   6          2、第二次触摸继电器1 (PCB板最边上这个继电器)断开，继电器2 (PCB板中间继电器)
             -通220V电源。
   7          
   8          3、第三次触摸继电器1 、摸继电器2 都接通220V电源。
   9          
  10          4、第四次触摸又回到第一次触摸实现的功能，只有(PCB板最边上这个继电器)接通2
             -20V电源。
  11          ************************************************/
  12          
  13          #include  "stc8g1k_code.h"    
  14          #include  "STC8xxxx.h"  
  15          #include  "STC8G_H_GPIO.h"
  16          #include  "STC8G_H_ADC.h"
  17          #include  "STC8G_H_NVIC.h"
  18          #include  "string.h"
  19          #include  "global.h"
  20          #include  "led2_digital_tube.h"
  21          #include  "uart.h"
  22          #include  "infrared.h"
  23          #include  "touch.h"
  24          #include  "temperature.h"
  25          #include  "buzzer.h"
  26          #include  "encryptionDecryption.h"
  27          
  28          #ifdef    UART_ENABLE
              #include  "uart.h"
              #endif
  31          
  32          #define ET2 0x04
  33           
  34          //数据定义
  35          u8 si_level;        //可控硅控制级数 0关闭 最大3档
  36          
  37          //函数声明
  38          static void Timer0Init(void);   //定时计数器0初始化函数
  39          static void Timer1Init(void);   //定时计数器1初始化函数
  40          static void Timer2Init(void);   //10毫秒@6.000MHz
  41          static void gpio_config(void);
  42          static void Int1_init(void);
  43          static void Int0_init(void);
  44          void rdelay_acton_fun(u8 action_value);
  45          void delay(u16 count);    //延时函数声明
  46          
  47          //-------------------------主函数----------------------------
  48          void main(void)
  49          {
  50   1        gpio_config();
  51   1      
  52   1        Timer0Init();   //定时计数器0初始化函数
C51 COMPILER V9.59.0.0   STC8G1K_CODE                                                      02/21/2023 10:54:57 PAGE 2   

  53   1        Timer1Init();   //定时计数器1初始化函数
  54   1        Timer2Init();   //10毫秒@6.000MHz
  55   1        //过零检测
  56   1        Int0_init();    //外部中断0初始化函数  过零检测脚
  57   1        //Int3_init();    //外部中断3初始化函数  
  58   1        infrared_init(); //红外初始化函数
  59   1        touch_init();    //触摸初始化函数
  60   1        buzzer_init();
  61   1        
  62   1        #ifdef UART_ENABLE
                UartInit();
                #endif
  65   1        EA = 1;         //开中断
  66   1        delay(500);     //等待配置稳定
  67   1        #ifdef UART_ENABLE
                PrintString1("STC8:\r\n");    //UART1发送一个字符串
                #endif
  70   1        
  71   1        WDT_CONTR = 0x23; //使能看门狗,溢出时间约为 0.5s
  72   1        //WDT_CONTR = 0x24; //使能看门狗,溢出时间约为 1s
  73   1        // WDT_CONTR = 0x27; //使能看门狗,溢出时间约为 8s
  74   1      
  75   1        temperature_init();
  76   1        rdelay_acton_fun(0);
  77   1        si_level =0;
  78   1        ID:
  79   1        if(id_compare())
  80   1        {
  81   2           WDT_CONTR |= 0x10;
  82   2           delay(500);
  83   2           goto ID;
  84   2        } 
  85   1        while(1)
  86   1        {   
  87   2           WDT_CONTR |= 0x10; //清看门狗,否则系统复位
  88   2           temperature_get_deal();    
  89   2           if(overtemperature_check())
  90   2              continue;
  91   2           infrared_check_deal(); 
  92   2           touch_check_deal();//触摸检测
  93   2           buzzer_run();
  94   2          
  95   2        }
  96   1      }
  97          
  98          
  99          static void gpio_config(void)
 100          {
 101   1        
 102   1         //数码管引脚初始化
 103   1         P3_MODE_OUT_PP(GPIO_Pin_5 | GPIO_Pin_7 |GPIO_Pin_4);   //推挽输出A F G       
 104   1         P1_MODE_OUT_PP(GPIO_Pin_6 | GPIO_Pin_4 | GPIO_Pin_2 |GPIO_Pin_3);//推挽输出B C D E  
 105   1         P1_MODE_OUT_PP(GPIO_Pin_0);   //推挽输出DIG2  
 106   1         P5_MODE_OUT_PP(GPIO_Pin_4);   //推挽输出DIG1 
 107   1         P54 = 0; P16=0;  //数码管不显示
 108   1      // ||GPIO_Pin_7
 109   1         //P5_MODE_OUT_PP(GPIO_Pin_5);   //推挽输出AH
 110   1         //P55 = 1;
 111   1        
 112   1         //触摸IC引脚初始化 
 113   1         P3_ST_ENABLE(GPIO_Pin_3);     //施密特触发使能
 114   1         P3_MODE_IN_HIZ(GPIO_Pin_3);   //高阻输入 
C51 COMPILER V9.59.0.0   STC8G1K_CODE                                                      02/21/2023 10:54:57 PAGE 3   

 115   1         //Int2_init();  //P3.6/INT2下降沿中断
 116   1      
 117   1         //可控硅控制IO初始化
 118   1         P1_MODE_OUT_PP(GPIO_Pin_7);   //推挽输出 
 119   1         SI_OFF();   //关断可控硅
 120   1         
 121   1         //蜂鸣器IO初始化
 122   1         P1_MODE_OUT_PP(GPIO_Pin_1);   //推挽输出 
 123   1         P11=1;
 124   1        
 125   1      /*
 126   1          #if   0
 127   1        //STC8G系列单片机除P3.0和P3.1外，所有I/O上电均为高阻输入状态，需先配置再使用
 128   1        P3M0 |=0x08;    //P3.3引脚为推挽输出模式
 129   1        P3M1 &=0xF7;    //P3.3引脚为推挽输出模式
 130   1        RSTCFG &=0xEF;    //复位引脚P5.4当做普通I/O引脚
 131   1        P5M0 |=0x10;    //P5.4引脚为推挽输出模式
 132   1        P5M1 &=0xEF;    //P5.4引脚为推挽输出模式
 133   1        P5M0 &=0xDF;    //P5.5引脚为准双向口模式
 134   1        P5M1 &=0xDF;    //P5.5引脚为准双向口模式
 135   1        #endif
 136   1          GPIO_InitTypeDef  GPIO_InitStructure;   //结构定义
 137   1      
 138   1          GPIO_InitStructure.Pin  = GPIO_Pin_0 | GPIO_Pin_1;    //指定要初始化的IO, GPIO_Pin_0 ~ GPIO_Pin_7
 139   1          GPIO_InitStructure.Mode = GPIO_PullUp;  //指定IO的输入或输出方式,GPIO_PullUp,GPIO_HighZ,GPIO_OU
             -T_OD,GPIO_OUT_PP
 140   1          GPIO_Inilize(GPIO_P3,&GPIO_InitStructure);  //初始化
 141   1        
 142   1         P3_PULL_UP_ENABLE(GPIO_Pin_0 | GPIO_Pin_1);//      
 143   1         //P3_PULL_UP_ENABLE(GPIO_Pin_1);//
 144   1        
 145   1         P1_MODE_OUT_PP(GPIO_Pin_0);   //推挽输出P1.0 控制中间第二个继电器
 146   1         P3_MODE_OUT_PP(GPIO_Pin_6 |GPIO_Pin_7);   //推挽输出P3.7 控制边上第一个继电器  //推挽输
             -出P3.6 红外管触摸IC 小板电源控制
 147   1        
 148   1         //P3_MODE_OUT_PP(GPIO_Pin_6);   //推挽输出P3.6 红外管触摸IC 小板电源控制
 149   1         P3_MODE_IN_HIZ(GPIO_Pin_3 | GPIO_Pin_4);   //施密特触发使能P3.3 连接触摸IC输出脚
 150   1         //P3_MODE_IN_HIZ(GPIO_Pin_4);   //施密特触发使能P3.4 连接红外管接收脚
 151   1        
 152   1         DELAY1_OFF;   
 153   1         DELAY2_OFF; 
 154   1         P36 = 0; 
 155   1      */
 156   1      }
 157          //-------------------------延时函数----------------------------
 158          void delay(u16 count)
 159          {
 160   1        while(count--)
 161   1        {
 162   2          _nop_();
 163   2        }
 164   1      }
 165          //函数功能：备份与还原参数
 166          void display_para(u8 bak)
 167          {
 168   1         static u8 btn_value_bak=0xff;
 169   1         if(1 == bak)
 170   1            btn_value_bak = btn_value;
 171   1         else
 172   1         {
 173   2             btn_value = btn_value_bak;
 174   2             rdelay_acton_fun(btn_value);
C51 COMPILER V9.59.0.0   STC8G1K_CODE                                                      02/21/2023 10:54:57 PAGE 4   

 175   2         }
 176   1      
 177   1      }
 178          void rdelay_acton_fun(u8 action_value)
 179          {
 180   1          buzzerEnableFlag = 1;
 181   1          led_display_enable=1; 
 182   1          if(method_res_compare())
 183   1            action_value = 6;
 184   1          
 185   1          switch(action_value)
 186   1          {
 187   2              case 0:  // 断开所有继电器
 188   2                led_display_enable=0;  //上电LED数码管不显示
 189   2                si_level = 0; 
 190   2              break;
 191   2              case 1:   //数码管显示--
 192   2                  digital_value[0]=0xff;
 193   2                  digital_value[1]=0xff;      
 194   2                  si_level = 0;
 195   2              break;
 196   2              case 2:  //数码管显示L1 
 197   2                  digital_value[0]=0x10;
 198   2                  digital_value[1]=0x01;
 199   2                  si_level = 1;
 200   2              break;
 201   2              case 3: 
 202   2                  digital_value[0]=0x10;
 203   2                  digital_value[1]=0x02;
 204   2                  si_level = 2;
 205   2              break;
 206   2              case 4: 
 207   2                  digital_value[0]=0x10;
 208   2                  digital_value[1]=0x03;
 209   2                  si_level = 3;
 210   2              break;
 211   2              case 5:
 212   2                  
 213   2                  digital_value[0]=0x0e;
 214   2                  digital_value[1]=0x01;  
 215   2                  si_level = 0;
 216   2              break;
 217   2              default:
 218   2                
 219   2              break;
 220   2          }
 221   1      }
 222          
 223          //-------------------------定时器初始化----------------------------
 224          static void Timer0Init(void)    //139微秒@6.000MHz
 225          {
 226   1        AUXR &= 0x7F;   //定时器时钟12T模式
 227   1        TMOD &= 0xF0;   //设置定时器模式
 228   1        TMOD |= 0x02;   //设置定时器模式
 229   1        TL0 = 0xBA;   //设置定时初值
 230   1        TH0 = 0xBA;   //设置定时重载值
 231   1        TF0 = 0;    //清除TF0标志
 232   1        TR0 = 1;    //定时器0开始计时
 233   1        ET0 = 1;    //使能T0中断
 234   1      }
 235          static void Timer1Init(void)    //125毫秒@6.000MHz
 236          {
C51 COMPILER V9.59.0.0   STC8G1K_CODE                                                      02/21/2023 10:54:57 PAGE 5   

 237   1        AUXR &= 0xBF;   //定时器时钟12T模式
 238   1        TMOD &= 0x0F;   //设置定时器模式
 239   1        TL1 = 0xDC;   //设置定时初值
 240   1        TH1 = 0x0B;   //设置定时初值
 241   1        TF1 = 0;    //清除TF1标志
 242   1        TR1 = 1;    //定时器1开始计时
 243   1        
 244   1        ET1 = 1;    //使能T1中断
 245   1      }
 246          static void Timer2Init(void)    //10毫秒@6.000MHz
 247          {
 248   1        AUXINTIF &= ~T2IF; //清中断标志
 249   1        AUXR &= 0xFB;   //定时器时钟12T模式
 250   1        T2L = 0x78;   //设置定时初值
 251   1        T2H = 0xEC;   //设置定时初值
 252   1        AUXR &= ~0x10;//定时器2不计时
 253   1        IE2 = ET2;    //使能定时器中断
 254   1      }
 255          
 256          //-------------------------外部中断0过零检测中断初始化-------------------------
 257          static void Int0_init(void)
 258          {
 259   1        IT0 = 1;  //触发方式为下降沿触发
 260   1        EX0 = 1;  //使能INT0中断
 261   1      }
 262          
 263          
 264          //-------------------------外部中断0服务函数-------------------------
 265          void INT0_ISR() interrupt INT0_VECTOR   //过零检测中断
 266          {
 267   1        //可控硅控制方法：过零点后可控硅在没有外部触发条件下，自动关闭.
 268   1        //用time2作延时，time2最长延时长为10ms，把10ms分成3份，即每份时长为3.3ms
 269   1        //第一档延时时长为10-3.3ms=6.7ms，第二档延时时长为10-3.3ms*2=3.4ms，第三档全波形
             -作不延时.过零点时直接触发可控硅导通
 270   1        //所以一二档定时器初始值计算如下：
 271   1        //incrementV=(0xffff-0xEC78)/4=0x0662; ---incrementV变量值：把10ms分成3份每一份的初始值的
             -增量值
 272   1        //timeVal=0xEC78 + incrementV * si_level;---preTimeVal变量值：即是一二档定时器初始值
 273   1        
 274   1           //u16  timeVal;// 0x0662; // 0x04c9; //0x1327;
 275   1           AUXR &= ~0x10;   //定时器2停止计时
 276   1           
 277   1           switch(si_level)
 278   1           {
 279   2             case 0:
 280   2                SI_OFF();  //关断可控硅 
 281   2                return;
 282   2             case 1:
 283   2                 SI_OFF();  //关断可控硅 
 284   2                 //timeVal = 0xEC78 + 0x0662; //定时器初始值越大延时时长越短,定时器工作方式是
             -量溢出产生中断.
 285   2                 TH2=242;//timeVal/256;  62170/256;
 286   2                 TL2=218;//timeVal%256;  62170-61952
 287   2              break;
 288   2             case 2:
 289   2                 SI_OFF();  //关断可控硅 
 290   2                 //timeVal = 0xEC78 + 0x0662 *2;
 291   2                 TH2=249;//timeVal/256;   63804/256
 292   2                 TL2=60;//timeVal%256;   63804-63744
 293   2              break;
 294   2             case 3:
 295   2                 SI_ON();   //开启可控硅
C51 COMPILER V9.59.0.0   STC8G1K_CODE                                                      02/21/2023 10:54:57 PAGE 6   

 296   2                 return;
 297   2              break;
 298   2           } 
 299   1              
 300   1           AUXR |= 0x10;    //定时器2开始计时;
 301   1          
 302   1      }
 303          
 304          
 305          
 306          void INT2_ISR() interrupt INT2_VECTOR  //触摸按键
 307          {
 308   1        
 309   1      }
 310          u8 display_cnt=0;
 311          void Time0_Handler_Callback(void)   interrupt TIMER0_VECTOR   //139us 进中断时已经清除标志//任务
             -标记回调函数
 312          {
 313   1         if(IR_time < 0xfc)
 314   1           IR_time++;
 315   1        
 316   1         Touch_time++;
 317   1      
 318   1         if(display_cnt++ > 40)
 319   1         {
 320   2             display_cnt = 0;
 321   2             led_display();
 322   2         }
 323   1           
 324   1      }
 325          void Time1_Handler_Callback(void) interrupt TIMER1_VECTOR   //125ms 进中断时已经清除标志//任务
             -记回调函数
 326          {
 327   1        static u8 secCount=0;
 328   1      
 329   1        buzzer_timer++;
 330   1        
 331   1        if(++secCount >= 8)
 332   1        {
 333   2           secCount = 0;
 334   2           secFlag=1;
 335   2        }
 336   1        
 337   1        
 338   1        #if 0
                count--;
                if(count == 0)
                {
                   IR_TimeFlag = 1;
                   ET1 = 1;//
                }
                #endif
 346   1        
 347   1      }
 348          
 349          void Time2_Handler_Callback(void) interrupt TIMER2_VECTOR 
 350          {
 351   1          AUXINTIF &= ~T2IF; //清中断标志
 352   1          SI_ON();   //开启可控硅
 353   1          //delay(10);  //延时2us
 354   1          //SI_OFF();  //关断可控硅 
 355   1          
C51 COMPILER V9.59.0.0   STC8G1K_CODE                                                      02/21/2023 10:54:57 PAGE 7   

 356   1      }
 357          
 358          
 359          
 360          
 361          
 362          
 363          
 364          
 365          //-------------------------定时器0初始化----------------------------
 366          #if 0
              static void Time0_init(void)  //139微秒@11.0592MHz
              {
                AUXR &= 0x7F; //定时器时钟12T模式，工作方式2
                TMOD &= 0xF0; 
                TMOD |= 0x02; 
                TL0 = 0x80;   
                TH0 = 0x80;   
                TF0 = 0;    //清除标志
                ET0 = 1;    //使能T0中断
                TR0 = 1;    //启动T0
              }
              //-------------------------定时器1初始化---------------------------
              
              static void Time1_init(void)  //278微秒@11.0592MHz
              { 
                  AUXR |= 0x40;//模式2 1T
                  TMOD &= 0x0F; 
              }
              #endif
 386          
 387          
 388          
 389          
 390          
 391          
 392          
 393          
 394          
 395          #if 0
              //-------------------------红外发送高电平----------------------------
              void Wait_High(a)//a*280uS 
              {
                unsigned char k;
                IR_TimeFlag = 0;
                count = a;
                T1_START();
                while(!IR_TimeFlag)  //38khz载波
                {
                  _nop_();
                  _nop_();
                  k = 23;
                  while (--k);
                  IR_IO = ~IR_IO;
                }
                IR_IO = 1;
              }
              //-------------------------红外发送低电平----------------------------
              void Wait_Low(a)//a*280uS 
              {
                IR_IO = 1;
                IR_TimeFlag = 0;
C51 COMPILER V9.59.0.0   STC8G1K_CODE                                                      02/21/2023 10:54:57 PAGE 8   

                count = a;
                T1_START();
                while(!IR_TimeFlag);
              }
              //-------------------------红外发送单字节数据----------------------------
              void Send_IR(u8 dat)
              {
                unsigned char i,j;
                Wait_High(2);//0.56ms 
                Wait_Low(4);//1.12ms  
               
                for(j=0;j<8;j++)
                {
                  Wait_High(1);//0.28ms 
                  if(dat&0x01)
                  {
                    Wait_Low(2);// 0.56ms 
                  }
                  else
                  {
                    Wait_Low(1);//0.28ms
                  }
                  dat = dat>>1;    
                }
                
                Wait_High(1);//0.28ms 
              }
              #endif
 446          
 447          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    531    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
