C51 COMPILER V9.59.0.0   INFRARED                                                          02/21/2023 10:54:42 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE INFRARED
OBJECT MODULE PLACED IN .\Objects\infrared.obj
COMPILER INVOKED BY: C:\Keil_C51\C51\BIN\C51.EXE src\infrared.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\src;.\Driver\inc;.\Dri
                    -ver\src) DEBUG OBJECTEXTEND PRINT(.\Listings\infrared.lst) TABS(2) OBJECT(.\Objects\infrared.obj)

line level    source

   1          #include  "infrared.h"
   2          #include  "stc8g1k_code.h"
   3          #include  "STC8xxxx.h"
   4          #include  "global.h"
   5          #include  "uart.h"
   6          #include  "string.h"
   7          //数据定义
   8          
   9          bit edgeFlag = 0;   //红外管接收脚边沿标识
  10          bit sysFunFlag;      //系统功能标志
  11          bit IR_Flag=0;    //红外数据接收完成标志位
  12          u8 IR_time=0;     //下降沿之间的时间计数值
  13          u8 IR_data[9];    //引导码+8个位数据各自占用的时间
  14          u8 IR_bit;    //变量IR_bit用于指示红外数据的位数
  15          u8 btn_value=0; //红外按键键值寄存器
  16          u8 IRdata_len = 0; //红外管接收到数据长度
  17          u8 IRdata[IR_DATA_BUFFER_SIZE];
  18          u32 time_cnt=0;     //定时计数器 计数单位1s
  19          
  20          
  21          static void IR_Data_deal(void);
  22          static u8 IR_decode(void);  
  23          static void Int1_init(void);
  24          
  25          void infrared_init(void)
  26          {
  27   1          btn_value = 0;
  28   1          edgeFlag = 1;
  29   1          //红外输出检测
  30   1          Int1_init();    //外部中断1初始化函数  红外输出脚  //触摸IC输出脚 
  31   1        
  32   1      }
  33          void infrared_check_deal(void)
  34          {
  35   1          if(IR_Flag)       //红外数据接收完成
  36   1          {
  37   2              //后处理数据
  38   2              if(IR_time >0xf0)
  39   2              {   
  40   3                  IR_time =0; 
  41   3                  IR_Flag =0;         
  42   3                  IR_Data_deal();
  43   3              }
  44   2          }
  45   1      }
  46          
  47          //-------------------红外接收数据处理-------------------------------
  48          static void IR_Data_deal(void)
  49          {
  50   1          u8 dat=0,i,light=0,onoff=0;
  51   1      
  52   1          for(i=0;i<IRdata_len;i++) 
  53   1          {
  54   2              if(IRdata[i]==IR_LIGHT_BUTTON)
C51 COMPILER V9.59.0.0   INFRARED                                                          02/21/2023 10:54:42 PAGE 2   

  55   2                 light++;
  56   2              else  if(IRdata[i]==IR_ONOFF_BUTTON)
  57   2                 onoff++;
  58   2          }
  59   1          if(IRdata_len == 0)
  60   1             return;
  61   1          if(light > onoff)
  62   1             dat = IR_LIGHT_BUTTON;
  63   1          else if(light < onoff)
  64   1             dat = IR_ONOFF_BUTTON;
  65   1          
  66   1          IRdata_len = 0;
  67   1          
  68   1          switch(dat)//红外接收正确
  69   1          {
  70   2            case  IR_LIGHT_BUTTON:   //灯档位调节键
  71   2                   if(sysFunFlag == 1)
  72   2                   {
  73   3                     btn_value++;
  74   3                     if(btn_value > BUTTON_VALUE_MAX)
  75   3                     {
  76   4                        btn_value = 1;                
  77   4                     }
  78   3                   }
  79   2                   else return;                
  80   2            break;
  81   2            case  IR_ONOFF_BUTTON:  //电源开关键
  82   2                 if(sysFunFlag==1)
  83   2                 {
  84   3                     sysFunFlag = 0;
  85   3                     btn_value = 0;
  86   3                 }
  87   2                 else
  88   2                 {
  89   3                     sysFunFlag = 1;
  90   3                     btn_value = 1;
  91   3                 }               
  92   2            break;  
  93   2            default:
  94   2                  return;     
  95   2          }
  96   1          rdelay_acton_fun(btn_value);
  97   1      }
  98          
  99          //-------------------------红外接收解码-------------------------
 100          static u8 IR_decode(void)
 101          {
 102   1        u8 j;//,k;                
 103   1        u8 IR_Value = 0; 
 104   1        //k=0;              //先让变量k等于1，因为k为0时取出的将会是“引导码的时间间隔”
 105   1       
 106   1        for(j=0;j<=7;j++)       //内层循环8次为了拼合8个数据位为1个字节
 107   1        {
 108   2          if(IR_data[j]>=5)     //若“时间间隔”比5大那肯定是“1码”反之为“0码”
 109   2            IR_Value|=0x80;     //通过按位或运算高位填1
 110   2          if(j<7)               //若数据没有拼合完8次
 111   2            IR_Value>>=1;       //通过右移运算“腾出”位置准备下一位判定
 112   2          //k++;                  //下标变量自增
 113   2        }
 114   1        
 115   1        return IR_Value;        //返回红外接收的数据
 116   1      }
C51 COMPILER V9.59.0.0   INFRARED                                                          02/21/2023 10:54:42 PAGE 3   

 117          
 118          //-------------------------外部中断1红外线输出引脚初始化-------------------------
 119          static void Int1_init(void)
 120          {
 121   1        IT1 = 1;  //触发方式为下降沿触发
 122   1        EX1 = 1;  //使能INT1中断
 123   1      }
 124          void INT1_ISR() interrupt INT1_VECTOR  //连接红外管接收脚
 125          {
 126   1        static u8 isRec=0; 
 127   1      
 128   1        if(edgeFlag) //下沿中断
 129   1        {   //高电平达到9ms为开始 位
 130   2            IT1 = 0;  //触发方式为上沿触发
 131   2            EX1 = 1;  //使能INT1中断
 132   2            edgeFlag = 0; 
 133   2            if(IR_time>50)  //判断引导码(9ms+1.12ms)（0.56ms+1.12ms）
 134   2            {
 135   3                  isRec = 1;
 136   3                  IR_bit = 0;
 137   3            }
 138   2            
 139   2        }
 140   1        else
 141   1        {   //上沿中断
 142   2          IT1 = 1;  //触发方式为下降沿触发
 143   2          EX1 = 1;  //使能INT1中断
 144   2          edgeFlag = 1;
 145   2      
 146   2          if(isRec)
 147   2          {
 148   3                  IR_data[IR_bit]=IR_time;    //存储相应位时间宽度
 149   3                  IR_time=0;            //清零时间宽度计数值
 150   3                  IR_bit++;             //位数变量自增
 151   3                  if(IR_bit==8)         //如果达到了9位（引导码+8个数据位）
 152   3                  {
 153   4                    IR_Flag=1;          //红外数据接收完成标志位置1
 154   4                    IR_bit=0;           //位数变量清零
 155   4                    isRec =0;
 156   4                    
 157   4                    IRdata[IRdata_len] = IR_decode();
 158   4                    ++IRdata_len;
 159   4                    if(IRdata_len >= IR_DATA_BUFFER_SIZE) 
 160   4                        IRdata_len=0;
 161   4                  }
 162   3          }
 163   2        }
 164   1        IR_time =0;  //清零时间宽度计数值
 165   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    318    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     28    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
