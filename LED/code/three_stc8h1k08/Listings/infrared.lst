C51 COMPILER V9.59.0.0   INFRARED                                                          02/15/2023 10:30:41 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE INFRARED
OBJECT MODULE PLACED IN .\Objects\infrared.obj
COMPILER INVOKED BY: C:\Keil_C51\C51\BIN\C51.EXE src\infrared.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\src;.\Driver\inc;
                    -.\Driver\src) DEBUG PRINT(.\Listings\infrared.lst) TABS(2) OBJECT(.\Objects\infrared.obj)

line level    source

   1          #include  "infrared.h"
   2          #include  "stc8g1k_code.h"
   3          #include  "STC8xxxx.h"
   4          #include  "global.h"
   5          #include  "uart.h"
   6          #include  "string.h"
   7          //数据定义
   8          
   9          bit edgeFlag = 0;   //红外管接收脚边沿标识
  10          bit sysFunFlag;      //系统功能标志
  11          bit IR_Flag=0;    //红外数据接收完成标志位
  12          u8 IR_time=0;     //下降沿之间的时间计数值
  13          u8 IR_data[9];    //引导码+8个位数据各自占用的时间
  14          u8 IR_bit;    //变量IR_bit用于指示红外数据的位数
  15          u8 btn_value=0; //红外按键键值寄存器
  16          u8 IRdata_len = 0; //红外管接收到数据长度
  17          u8 IRdata[IR_DATA_BUFFER_SIZE];
  18          u32 time_cnt=0;     //定时计数器 计数单位1s
  19          
  20          
  21          static void IR_Data_deal(void);
  22          static u8 IR_decode(void);  
  23          static void Int1_init(void);
  24          
  25          void infrared_init(void)
  26          {
  27   1          btn_value = 0;
  28   1          edgeFlag = 1;
  29   1          //红外输出检测
  30   1          Int1_init();    //外部中断1初始化函数  红外输出脚  //触摸IC输出脚 
  31   1        
  32   1      }
  33          void infrared_check_deal(void)
  34          {
  35   1          if(IR_Flag)       //红外数据接收完成
  36   1          {
  37   2              //后处理数据
  38   2              if(IR_time >0xf0)
  39   2              {   
  40   3                  IR_time =0; 
  41   3                  IR_Flag =0;         
  42   3                  IR_Data_deal();
  43   3              }
  44   2          }
  45   1      }
  46          
  47          //-------------------红外接收数据处理-------------------------------
  48          static void IR_Data_deal(void)
  49          {
  50   1          u8 dat=0,i,light=0,onoff=0;
  51   1      
  52   1          for(i=0;i<IRdata_len;i++) 
  53   1          {
  54   2              if(IRdata[i]==IR_LIGHT_BUTTON)
C51 COMPILER V9.59.0.0   INFRARED                                                          02/15/2023 10:30:41 PAGE 2   

  55   2                 light++;
  56   2              else  if(IRdata[i]==IR_ONOFF_BUTTON)
  57   2                 onoff++;
  58   2          }
  59   1          if(IRdata_len == 0)
  60   1             return;
  61   1          if(/*light >= IRdata_len/2 && */light > onoff)
  62   1             dat = IR_LIGHT_BUTTON;
  63   1          else if(/*onoff >= IRdata_len/2 && */light < onoff)
  64   1             dat = IR_ONOFF_BUTTON;
  65   1          
  66   1          //memset(IRdata,0,IR_DATA_BUFFER_SIZE);
  67   1          IRdata_len = 0;
  68   1          
  69   1          switch(dat)//红外接收正确
  70   1          {
  71   2            case  IR_LIGHT_BUTTON:   //灯档位调节键
  72   2                   sysFunFlag=1;
  73   2                   btn_value++;
  74   2                   if(btn_value > BUTTON_VALUE_MAX)
  75   2                   {
  76   3                      btn_value = 0;
  77   3                      sysFunFlag = 0;
  78   3                   }
  79   2            break;
  80   2            case  IR_ONOFF_BUTTON:  //电源开关键
  81   2                 if(sysFunFlag==1)
  82   2                 {
  83   3                     sysFunFlag = 0;
  84   3                     btn_value = 0;
  85   3                 }
  86   2                 else
  87   2                 {
  88   3                     sysFunFlag = 1;
  89   3                     btn_value = 1;
  90   3                 }               
  91   2            break;  
  92   2            default:
  93   2                  return;     
  94   2          }
  95   1          rdelay_acton_fun(btn_value);
  96   1      }
  97          
  98          //-------------------------红外接收解码-------------------------
  99          static u8 IR_decode(void)
 100          {
 101   1        u8 j;//,k;                
 102   1        u8 IR_Value = 0; 
 103   1        //k=0;              //先让变量k等于1，因为k为0时取出的将会是“引导码的时间间隔”
 104   1       
 105   1        for(j=0;j<=7;j++)       //内层循环8次为了拼合8个数据位为1个字节
 106   1        {
 107   2          if(IR_data[j]>=5)     //若“时间间隔”比5大那肯定是“1码”反之为“0码”
 108   2            IR_Value|=0x80;     //通过按位或运算高位填1
 109   2          if(j<7)               //若数据没有拼合完8次
 110   2            IR_Value>>=1;       //通过右移运算“腾出”位置准备下一位判定
 111   2          //k++;                  //下标变量自增
 112   2        }
 113   1        
 114   1        return IR_Value;        //返回红外接收的数据
 115   1      }
 116          
C51 COMPILER V9.59.0.0   INFRARED                                                          02/15/2023 10:30:41 PAGE 3   

 117          //-------------------------外部中断1红外线输出引脚初始化-------------------------
 118          static void Int1_init(void)
 119          {
 120   1        IT1 = 1;  //触发方式为下降沿触发
 121   1        EX1 = 1;  //使能INT1中断
 122   1      }
 123          void INT1_ISR() interrupt INT1_VECTOR  //连接红外管接收脚
 124          {
 125   1        static u8 isRec=0; 
 126   1      
 127   1        if(edgeFlag) //下沿中断
 128   1        {   //高电平达到9ms为开始 位
 129   2            IT1 = 0;  //触发方式为上沿触发
 130   2            EX1 = 1;  //使能INT1中断
 131   2            edgeFlag = 0; 
 132   2            if(IR_time>50)  //判断引导码(9ms+1.12ms)（0.56ms+1.12ms）
 133   2            {
 134   3                  isRec = 1;
 135   3                  IR_bit = 0;
 136   3            }
 137   2            
 138   2        }
 139   1        else
 140   1        {   //上沿中断
 141   2          IT1 = 1;  //触发方式为下降沿触发
 142   2          EX1 = 1;  //使能INT1中断
 143   2          edgeFlag = 1;
 144   2      
 145   2          if(isRec)
 146   2          {
 147   3                  IR_data[IR_bit]=IR_time;    //存储相应位时间宽度
 148   3                  IR_time=0;            //清零时间宽度计数值
 149   3                  IR_bit++;             //位数变量自增
 150   3                  if(IR_bit==8)         //如果达到了9位（引导码+8个数据位）
 151   3                  {
 152   4                    IR_Flag=1;          //红外数据接收完成标志位置1
 153   4                    IR_bit=0;           //位数变量清零
 154   4                    isRec =0;
 155   4                    
 156   4                    IRdata[IRdata_len] = IR_decode();
 157   4                    ++IRdata_len;
 158   4                    if(IRdata_len >= IR_DATA_BUFFER_SIZE) 
 159   4                        IRdata_len=0;
 160   4                  }
 161   3          }
 162   2        }
 163   1        IR_time =0;  //清零时间宽度计数值
 164   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    325    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     28    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
C51 COMPILER V9.59.0.0   INFRARED                                                          02/15/2023 10:30:41 PAGE 4   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
