C51 COMPILER V9.59.0.0   INFRARED                                                          02/11/2023 16:58:34 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE INFRARED
OBJECT MODULE PLACED IN .\Objects\infrared.obj
COMPILER INVOKED BY: C:\Keil_C51\C51\BIN\C51.EXE src\infrared.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\src;.\Driver\inc;
                    -.\Driver\src) DEBUG PRINT(.\Listings\infrared.lst) TABS(2) OBJECT(.\Objects\infrared.obj)

line level    source

   1          #include  "infrared.h"
   2          #include  "stc8g1k_code.h"
   3          #include  "STC8xxxx.h"
   4          #include  "global.h"
   5          #include  "uart.h"
   6          #include  "string.h"
   7          //数据定义
   8          
   9          bit edgeFlag = 0;   //红外管接收脚边沿标识
  10          bit sysFunFlag;      //系统功能标志
  11          bit IR_Flag=0;    //红外数据接收完成标志位
  12          u8 IR_time=0;     //下降沿之间的时间计数值
  13          u8 IR_data[9];    //引导码+8个位数据各自占用的时间
  14          u8 IR_bit;    //变量IR_bit用于指示红外数据的位数
  15          u8 btn_value=0; //红外按键键值寄存器
  16          u8 IRdata_len = 0; //红外管接收到数据长度
  17          u8 IRdata[IR_DATA_BUFFER_SIZE];
  18          u32 time_cnt=0;     //定时计数器 计数单位1s
  19          
  20          
  21          static void IR_Data_deal(void);
  22          static u8 IR_decode(void);  
  23          static void Int1_init(void);
  24          
  25          void infrared_init(void)
  26          {
  27   1          btn_value = 0;
  28   1          edgeFlag = 1;
  29   1          //红外输出检测
  30   1          Int1_init();    //外部中断1初始化函数  红外输出脚  //触摸IC输出脚 
  31   1        
  32   1      }
  33          void infrared_check_deal(void)
  34          {
  35   1          u8 num=0;
  36   1          if(IR_Flag)       //红外数据接收完成
  37   1          {
  38   2            IR_Flag=0;      
  39   2          }     
  40   1          else  
  41   1          {
  42   2            //125ms 后处理数据
  43   2            if(IR_time >0xf0)
  44   2            {    
  45   3              IR_Data_deal();
  46   3            }
  47   2          }
  48   1      }
  49          
  50          //-------------------红外接收数据处理-------------------------------
  51          static void IR_Data_deal(void)
  52          {
  53   1          u8 dat=0,i,light=0,onoff=0;
  54   1      
C51 COMPILER V9.59.0.0   INFRARED                                                          02/11/2023 16:58:34 PAGE 2   

  55   1          for(i=0;i<IRdata_len;i++) 
  56   1          {
  57   2              if(IRdata[i]==IR_LIGHT_BUTTON)
  58   2                 light++;
  59   2              else  if(IRdata[i]==IR_ONOFF_BUTTON)
  60   2                 onoff++;
  61   2          }
  62   1          if(IRdata_len == 0)
  63   1             return;
  64   1          if(light >= IRdata_len/2 && light > onoff)
  65   1             dat = IR_LIGHT_BUTTON;
  66   1          else if(onoff >= IRdata_len/2 && light < onoff)
  67   1             dat = IR_ONOFF_BUTTON;
  68   1          
  69   1          memset(IRdata,0,IR_DATA_BUFFER_SIZE);
  70   1          IRdata_len = 0;
  71   1          
  72   1          switch(dat)//红外接收正确
  73   1          {
  74   2            case  IR_LIGHT_BUTTON:   //灯档位调节键
  75   2                   sysFunFlag=1;
  76   2                   btn_value++;
  77   2                   if(btn_value > BUTTON_VALUE_MAX)
  78   2                   {
  79   3                      btn_value = 0;
  80   3                      sysFunFlag = 0;
  81   3                   }
  82   2            break;
  83   2            case  IR_ONOFF_BUTTON:  //电源开关键
  84   2                 if(sysFunFlag==1)
  85   2                 {
  86   3                     sysFunFlag = 0;
  87   3                     btn_value = 0;
  88   3                 }
  89   2                 else
  90   2                 {
  91   3                     sysFunFlag = 1;
  92   3                     btn_value = 1;
  93   3                 }               
  94   2            break;  
  95   2            default:
  96   2                  return;     
  97   2          }
  98   1          rdelay_acton_fun(btn_value);
  99   1      }
 100          
 101          //-------------------------红外接收解码-------------------------
 102          static u8 IR_decode(void)
 103          {
 104   1        u8 j,k;               
 105   1        u8 IR_Value = 0; 
 106   1        k=0;              //先让变量k等于1，因为k为0时取出的将会是“引导码的时间间隔”
 107   1       
 108   1        for(j=0;j<=7;j++)       //内层循环8次为了拼合8个数据位为1个字节
 109   1        {
 110   2          if(IR_data[k]>=5)     //若“时间间隔”比5大那肯定是“1码”反之为“0码”
 111   2            IR_Value|=0x80;     //通过按位或运算高位填1
 112   2          if(j<7)               //若数据没有拼合完8次
 113   2            IR_Value>>=1;       //通过右移运算“腾出”位置准备下一位判定
 114   2          k++;                  //下标变量自增
 115   2        }
 116   1        
C51 COMPILER V9.59.0.0   INFRARED                                                          02/11/2023 16:58:34 PAGE 3   

 117   1        return IR_Value;        //返回红外接收的数据
 118   1      }
 119          
 120          //-------------------------外部中断1红外线输出引脚初始化-------------------------
 121          static void Int1_init(void)
 122          {
 123   1        IT1 = 1;  //触发方式为下降沿触发
 124   1        EX1 = 1;  //使能INT1中断
 125   1      }
 126          void INT1_ISR() interrupt INT1_VECTOR  //连接红外管接收脚
 127          {
 128   1        static u8 isRec=0; 
 129   1      
 130   1        if(edgeFlag) //下沿中断
 131   1        {   //高电平达到9ms为开始 位
 132   2            IT1 = 0;  //触发方式为上沿触发
 133   2            EX1 = 1;  //使能INT1中断
 134   2            edgeFlag = 0; 
 135   2            if(IR_time>55)  //判断引导码(9ms+1.12ms)（0.56ms+1.12ms）
 136   2            {
 137   3                  isRec = 1;
 138   3                  IR_bit = 0;
 139   3            }
 140   2            IR_time =0;  //清零时间宽度计数值
 141   2        }
 142   1        else
 143   1        {   //上沿中断
 144   2          IT1 = 1;  //触发方式为下降沿触发
 145   2          EX1 = 1;  //使能INT1中断
 146   2          edgeFlag = 1;
 147   2      
 148   2          if(isRec)
 149   2          {
 150   3                  IR_data[IR_bit]=IR_time;    //存储相应位时间宽度
 151   3                  IR_time=0;            //清零时间宽度计数值
 152   3                  IR_bit++;             //位数变量自增
 153   3                  if(IR_bit==8)         //如果达到了9位（引导码+8个数据位）
 154   3                  {
 155   4                    IR_Flag=1;          //红外数据接收完成标志位置1
 156   4                    IR_bit=0;           //位数变量清零
 157   4                    isRec =0;
 158   4                    
 159   4                    IRdata[IRdata_len++] = IR_decode();
 160   4                    if(IRdata_len >= IR_DATA_BUFFER_SIZE) 
 161   4                        IRdata_len=0;
 162   4                  }
 163   3          }
 164   2          IR_time =0;  //清零时间宽度计数值
 165   2        }
 166   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    352    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     28       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
C51 COMPILER V9.59.0.0   INFRARED                                                          02/11/2023 16:58:34 PAGE 4   

   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
