C51 COMPILER V9.59.0.0   UART                                                              09/18/2022 12:17:16 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\uart.obj
COMPILER INVOKED BY: C:\Keil_C51_v5\C51\BIN\C51.EXE src\uart.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\src;.\Driver\inc) 
                    -DEBUG PRINT(.\Listings\uart.lst) TABS(2) OBJECT(.\Objects\uart.obj)

line level    source

   1          #include  "type_def.h"
   2          #include "intrins.h"
   3          #include "uart.h"
   4          #include "STC8xxxx.h"
   5          
   6          
   7          
   8          #define  FOSC  6000000UL//11059200UL //
   9          #define  BRT  (65536 - FOSC / 9600 / 4)
  10          
  11          #ifdef UART1
  12          #define COM_TX1_Lenth 30
  13          #define COM_RX1_Lenth 30
  14          #endif
  15          
  16          volatile  bit busy;
  17          
  18          #ifdef UART1
  19          COMx_Define COM1;
  20          u8  xdata TX1_Buffer[COM_TX1_Lenth];  //发送缓冲
  21          u8  xdata RX1_Buffer[COM_RX1_Lenth];  //接收缓冲
  22          #endif
  23          
  24          u8 UART_Configuration(u8 UARTx, COMx_InitDefine *COMx)
  25          {
  26   1        u8  i;
  27   1        u32 j;
  28   1        
  29   1      #ifdef UART1
  30   1        if(UARTx == UART1)
  31   1        {
  32   2          COM1.id = 1;
  33   2          COM1.TX_read    = 0;
  34   2          COM1.TX_write   = 0;
  35   2          COM1.B_TX_busy  = 0;
  36   2          COM1.RX_Cnt     = 0;
  37   2          COM1.RX_TimeOut = 0;
  38   2          COM1.B_RX_OK    = 0;
  39   2          for(i=0; i<COM_TX1_Lenth; i++)  TX1_Buffer[i] = 0;
  40   2          for(i=0; i<COM_RX1_Lenth; i++)  RX1_Buffer[i] = 0;
  41   2      
  42   2          if(COMx->UART_Polity > Polity_3)  return 2; //错误
  43   2          UART1_Polity(COMx->UART_Polity);  //指定中断优先级(低到高) Polity_0,Polity_1,Polity_2,Polity_3
  44   2          if(COMx->UART_Mode > UART_9bit_BRTx)  return 2; //模式错误
  45   2          SCON = (SCON & 0x3f) | COMx->UART_Mode;
  46   2          if((COMx->UART_Mode == UART_9bit_BRTx) || (COMx->UART_Mode == UART_8bit_BRTx))  //可变波特率
  47   2          {
  48   3            j = (FOSC / 4) / COMx->UART_BaudRate; //按1T计算
  49   3            if(j >= 65536UL)  return 2; //错误
  50   3            j = 65536UL - j;
  51   3            if(COMx->UART_BRT_Use == BRT_Timer1)
  52   3            {
  53   4              TR1 = 0;
  54   4              AUXR &= ~0x01;    //S1 BRT Use Timer1;
C51 COMPILER V9.59.0.0   UART                                                              09/18/2022 12:17:16 PAGE 2   

  55   4              TMOD &= ~(1<<6);  //Timer1 set As Timer
  56   4              TMOD &= ~0x30;    //Timer1_16bitAutoReload;
  57   4              AUXR |=  (1<<6);  //Timer1 set as 1T mode
  58   4              TH1 = (u8)(j>>8);
  59   4              TL1 = (u8)j;
  60   4              ET1 = 0;  //禁止中断
  61   4              TMOD &= ~0x40;  //定时
  62   4              INT_CLKO &= ~0x02;  //不输出时钟
  63   4              TR1  = 1;
  64   4            }
  65   3            else if(COMx->UART_BRT_Use == BRT_Timer2)
  66   3            {
  67   4              AUXR &= ~(1<<4);  //Timer stop
  68   4              AUXR |= 0x01;   //S1 BRT Use Timer2;
  69   4              AUXR &= ~(1<<3);  //Timer2 set As Timer
  70   4              AUXR |=  (1<<2);  //Timer2 set as 1T mode
  71   4              TH2 = (u8)(j>>8);
  72   4              TL2 = (u8)j;
  73   4              IE2  &= ~(1<<2);  //禁止中断
  74   4              AUXR |=  (1<<4);  //Timer run enable
  75   4            }
  76   3            else return 2;  //错误
  77   3          }
  78   2          else if(COMx->UART_Mode == UART_ShiftRight)
  79   2          {
  80   3            if(COMx->BaudRateDouble == ENABLE)  AUXR |=  (1<<5);  //固定波特率SysClk/2
  81   3            else                AUXR &= ~(1<<5);  //固定波特率SysClk/12
  82   3          }
  83   2          else if(COMx->UART_Mode == UART_9bit) //固定波特率SysClk*2^SMOD/64
  84   2          {
  85   3            if(COMx->BaudRateDouble == ENABLE)  PCON |=  (1<<7);  //固定波特率SysClk/32
  86   3            else                PCON &= ~(1<<7);  //固定波特率SysClk/64
  87   3          }
  88   2          if(COMx->UART_Interrupt == ENABLE)  ES = 1; //允许中断
  89   2          else                ES = 0; //禁止中断
  90   2          if(COMx->UART_RxEnable == ENABLE) REN = 1;  //允许接收
  91   2          else                REN = 0;  //禁止接收
  92   2          P_SW1 = (P_SW1 & 0x3f) | (COMx->UART_P_SW & 0xc0);  //切换IO
  93   2          return  0;
  94   2        }
  95   1      #endif
  96   1      #ifdef UART2
                if(UARTx == UART2)
                {
                  COM2.id = 2;
                  COM2.TX_read    = 0;
                  COM2.TX_write   = 0;
                  COM2.B_TX_busy  = 0;
                  COM2.RX_Cnt     = 0;
                  COM2.RX_TimeOut = 0;
                  COM2.B_RX_OK    = 0;
                  for(i=0; i<COM_TX2_Lenth; i++)  TX2_Buffer[i] = 0;
                  for(i=0; i<COM_RX2_Lenth; i++)  RX2_Buffer[i] = 0;
              
                  if((COMx->UART_Mode == UART_9bit_BRTx) ||(COMx->UART_Mode == UART_8bit_BRTx)) //可变波特率
                  {
                    if(COMx->UART_Polity > Polity_3)  return 2; //错误
                    UART2_Polity(COMx->UART_Polity);  //指定中断优先级(低到高) Polity_0,Polity_1,Polity_2,Polity_3
                    if(COMx->UART_Mode == UART_9bit_BRTx) S2CON |=  (1<<7); //9bit
                    else                  S2CON &= ~(1<<7); //8bit
                    j = (MAIN_Fosc / 4) / COMx->UART_BaudRate;  //按1T计算
                    if(j >= 65536UL)  return 2; //错误
C51 COMPILER V9.59.0.0   UART                                                              09/18/2022 12:17:16 PAGE 3   

                    j = 65536UL - j;
                    AUXR &= ~(1<<4);  //Timer stop
                    AUXR &= ~(1<<3);  //Timer2 set As Timer
                    AUXR |=  (1<<2);  //Timer2 set as 1T mode
                    TH2 = (u8)(j>>8);
                    TL2 = (u8)j;
                    IE2  &= ~(1<<2);  //禁止中断
                    AUXR |=  (1<<4);  //Timer run enable
                  }
                  else  return 2; //模式错误
                  if(COMx->UART_Interrupt == ENABLE)  IE2   |=  1;    //允许中断
                  else                IE2   &= ~1;    //禁止中断
                  if(COMx->UART_RxEnable == ENABLE) S2CON |=  (1<<4); //允许接收
                  else                S2CON &= ~(1<<4); //禁止接收
                  P_SW2 = (P_SW2 & ~1) | (COMx->UART_P_SW & 0x01);  //切换IO
                  return  0;
                }
              #endif
 135   1        
 136   1        return  2;  //错误
 137   1      }
 138          void Uart1_Isr() interrupt 4
 139          {
 140   1        u8 dat;
 141   1        #if 0
                if (TI)
                {
                    TI = 0;
                    busy = 0;
                }
                if (RI)
                {
                    RI = 0;
                  #if 0 
                    if(uart_revLen >= UART1_BUF_SIZE)
                      uart_revLen = 0;
                    
                    uart_rev[uart_revLen] = SBUF;
                    ++uart_revLen;
                    uart_time=0;
                  #endif
                }
                #endif
 160   1        
 161   1        if(RI)
 162   1        {
 163   2          RI = 0;
 164   2      
 165   2          if(COM1.B_RX_OK == 0)
 166   2          {
 167   3            //if(COM1.RX_Cnt >= COM_RX1_Lenth)  COM1.RX_Cnt = 0;
 168   3            //RX1_Buffer[COM1.RX_Cnt++] = SBUF;
 169   3            dat = SBUF;
 170   3            COM1.RX_TimeOut = TimeOutSet1;
 171   3          }
 172   2          
 173   2        }
 174   1      
 175   1        if(TI)
 176   1        {
 177   2          TI = 0;
 178   2          if(COM1.TX_read != COM1.TX_write)
C51 COMPILER V9.59.0.0   UART                                                              09/18/2022 12:17:16 PAGE 4   

 179   2          {
 180   3            SBUF = TX1_Buffer[COM1.TX_read];
 181   3            if(++COM1.TX_read >= COM_TX1_Lenth)   COM1.TX_read = 0;
 182   3          }
 183   2          else  COM1.B_TX_busy = 0;
 184   2        }
 185   1      }
 186          
 187          void TX1_write2buff(u8 dat) //写入发送缓冲，指针+1
 188          {
 189   1        while(COM1.B_TX_busy);
 190   1        TX1_Buffer[COM1.TX_write] = dat;  //装发送缓冲
 191   1        if(++COM1.TX_write >= COM_TX1_Lenth)  COM1.TX_write = 0;
 192   1      
 193   1        if(COM1.B_TX_busy == 0)   //空闲
 194   1        {  
 195   2          COM1.B_TX_busy = 1;   //标志忙
 196   2          TI = 1;         //触发发送中断
 197   2        }
 198   1      }
 199          
 200          void UartInit()
 201          {
 202   1        #if 0
                /*SCON = 0x50;//0x5A;
                T2L = BRT;
                T2H = BRT >> 8;
                AUXR = 0x15;  //ok
                */
                SCON = 0x50;
                //TMOD = 0x20;
                TL1 = BRT;
                TH1 = BRT >> 8;
                TR1 = 1;
                AUXR |= 0x40;
                busy = 0;
                
                //uart_revLen =0;
                //uart_sendLen=0;
                //uart_time=0;
                #endif
 220   1        
 221   1        
 222   1        COMx_InitDefine   COMx_InitStructure;         //结构定义
 223   1        COMx_InitStructure.UART_Mode      = UART_8bit_BRTx; //模式, UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART
             -_9bit_BRTx
 224   1        COMx_InitStructure.UART_BRT_Use   = BRT_Timer2;     //使用波特率, BRT_Timer1, BRT_Timer2 (注意: 串口2固定使
             -用BRT_Timer2)
 225   1        COMx_InitStructure.UART_BaudRate  = 9600ul;     //波特率, 一般 110 ~ 115200
 226   1        COMx_InitStructure.UART_RxEnable  = DISABLE;//ENABLE;       //接收允许,   ENABLE或DISABLE
 227   1        COMx_InitStructure.BaudRateDouble = DISABLE;      //波特率加倍, ENABLE或DISABLE
 228   1        COMx_InitStructure.UART_Interrupt = ENABLE;       //中断允许,   ENABLE或DISABLE
 229   1        COMx_InitStructure.UART_Polity    = Polity_0;     //指定中断优先级(低到高) Polity_0,Polity_1,Polity_2,Polit
             -y_3
 230   1        COMx_InitStructure.UART_P_SW      = UART1_SW_P30_P31; //切换端口,   UART1_SW_P30_P31,UART1_SW_P36_P37,UAR
             -T1_SW_P16_P17,UART1_SW_P43_P44
 231   1        UART_Configuration(UART1, &COMx_InitStructure);   //初始化串口1 UART1,UART2,UART3,UART4
 232   1      }
 233          void PrintString1(u8 *puts)
 234          {
 235   1          for (; *puts != 0;  puts++)  TX1_write2buff(*puts);   //遇到停止符0结束
 236   1      }
C51 COMPILER V9.59.0.0   UART                                                              09/18/2022 12:17:16 PAGE 5   

 237          #if 0
              void UartSend(char dat)
              {
                //while (!TI);
                //TI = 0;
                //SBUF = dat;
                while (busy);
                busy = 1;
                SBUF = dat;
              }
              
              void  sendData(void)
              {
                u8 i=0;
              
                for(;i<uart_sendLen;i++)
                  UartSend(uart_send[i]); 
                uart_sendLen=0;
              }
              #endif
 257          #if 0
              u8 revData()
              {
              
                  if(uart_revLen && uart_time>10)
                      return uart_revLen;
                
                  if(uart_time  > 20)
                  {
                     uart_revLen = 0;
                     uart_time =0;
                  }
                  return 0;
              }
              
              void uartDataDeal(u8 *revD,u8 len)
              {
                  u8  L,cod;
                  bit flag=1;
                  
                  uart_sendLen =  0;
                  L = protocol_judge(revD,len);
                  if(L == 0)return;
                  
                  //IWDG_ReloadCounter();//????? 
                  L = funAnalysis(revD,L,revD,&cod);
                  if(L == 0)return;
                   
                  //IWDG_ReloadCounter();//????? 
                  L = commandMerge1(uart_send,cod,revD,L);
                  if(L == 0)return; 
                  uart_sendLen = L;
              }
              
              void comm_data_deal()
              {
                if(revData()==0)
                  return;
              
                 //IWDG_ReloadCounter();//????? ??????????????,???
                 uartDataDeal(uart_rev,uart_revLen);//??????
                 uart_revLen = 0;
C51 COMPILER V9.59.0.0   UART                                                              09/18/2022 12:17:16 PAGE 6   

                 sendData();
                 
              }
              #endif
 303          
 304          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    690    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     60    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7      20
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
